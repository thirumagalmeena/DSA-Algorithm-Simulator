{
  "category": "Sorting Algorithms",
  "questions": [
    {
      "id": "sort-1",
      "type": "multiple_choice",
      "difficulty": "easy",
      "question": "What is the worst-case time complexity of Bubble Sort?",
      "options": ["O(n)", "O(n log n)", "O(n²)", "O(1)"],
      "correctAnswer": 2,
      "explanation": "Bubble Sort has O(n²) worst-case time complexity because it uses nested loops to compare and swap adjacent elements."
    },
    {
      "id": "sort-2", 
      "type": "multiple_choice",
      "difficulty": "easy",
      "question": "Which sorting algorithm is known for its divide and conquer approach?",
      "options": ["Bubble Sort", "Insertion Sort", "Merge Sort", "Selection Sort"],
      "correctAnswer": 2,
      "explanation": "Merge Sort uses a divide and conquer approach by recursively splitting the array and then merging sorted halves."
    },
    {
      "id": "sort-3",
      "type": "multiple_choice", 
      "difficulty": "medium",
      "question": "What is the space complexity of Merge Sort?",
      "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
      "correctAnswer": 2,
      "explanation": "Merge Sort requires O(n) additional space for the temporary arrays used during the merging process."
    },
    {
      "id": "sort-4",
      "type": "multiple_choice",
      "difficulty": "medium", 
      "question": "Which sorting algorithm performs best when the input is already mostly sorted?",
      "options": ["Quick Sort", "Insertion Sort", "Selection Sort", "Heap Sort"],
      "correctAnswer": 1,
      "explanation": "Insertion Sort has O(n) best-case time complexity and performs well on partially sorted data."
    },
    {
      "id": "sort-5",
      "type": "true_false",
      "difficulty": "easy",
      "question": "Quick Sort always has O(n log n) time complexity.",
      "correctAnswer": false,
      "explanation": "Quick Sort has O(n²) worst-case time complexity when the pivot selection is poor (e.g., already sorted array)."
    },
    {
      "id": "sort-6",
      "type": "multiple_choice",
      "difficulty": "hard",
      "question": "Which sorting algorithm is not stable?",
      "options": ["Merge Sort", "Insertion Sort", "Quick Sort", "Bubble Sort"],
      "correctAnswer": 2,
      "explanation": "Quick Sort is not stable because the relative order of equal elements may change during partitioning."
    },
    {
      "id": "sort-7",
      "type": "multiple_choice",
      "difficulty": "medium",
      "question": "What is the time complexity of Heap Sort?",
      "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
      "correctAnswer": 1,
      "explanation": "Heap Sort has O(n log n) time complexity for building the heap and performing extraction."
    },
    {
      "id": "sort-8",
      "type": "multiple_choice",
      "difficulty": "easy",
      "question": "Which sorting algorithm works by repeatedly finding the minimum element?",
      "options": ["Bubble Sort", "Insertion Sort", "Selection Sort", "Quick Sort"],
      "correctAnswer": 2,
      "explanation": "Selection Sort repeatedly finds the minimum element and places it at the beginning."
    },
    {
      "id": "sort-9",
      "type": "true_false",
      "difficulty": "medium",
      "question": "Bubble Sort is more efficient than Quick Sort for large datasets.",
      "correctAnswer": false,
      "explanation": "Bubble Sort has O(n²) time complexity while Quick Sort has O(n log n) average case, making Quick Sort much more efficient for large datasets."
    },
    {
      "id": "sort-10",
      "type": "multiple_choice",
      "difficulty": "medium",
      "question": "What is the best-case time complexity of Quick Sort?",
      "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
      "correctAnswer": 1,
      "explanation": "Quick Sort has O(n log n) best-case time complexity when the pivot divides the array into balanced partitions."
    },
    {
      "id": "sort-11",
      "type": "multiple_choice",
      "difficulty": "hard",
      "question": "Which sorting algorithm has O(1) space complexity?",
      "options": ["Merge Sort", "Heap Sort", "Quick Sort", "Insertion Sort"],
      "correctAnswer": 3,
      "explanation": "Insertion Sort has O(1) space complexity as it sorts in-place without requiring additional memory."
    },
    {
      "id": "sort-12",
      "type": "true_false",
      "difficulty": "easy",
      "question": "Merge Sort is an in-place sorting algorithm.",
      "correctAnswer": false,
      "explanation": "Merge Sort is not in-place; it requires O(n) additional space for merging."
    },
    {
      "id": "sort-13",
      "type": "multiple_choice",
      "difficulty": "medium",
      "question": "What is the average case time complexity of Quick Sort?",
      "options": ["O(n)", "O(n log n)", "O(n²)", "O(1)"],
      "correctAnswer": 1,
      "explanation": "Quick Sort has O(n log n) average case time complexity with good pivot selection."
    },
    {
      "id": "sort-14",
      "type": "multiple_choice",
      "difficulty": "hard",
      "question": "Which sorting algorithm is typically used for external sorting?",
      "options": ["Quick Sort", "Bubble Sort", "Merge Sort", "Insertion Sort"],
      "correctAnswer": 2,
      "explanation": "Merge Sort is well-suited for external sorting because it efficiently handles data that doesn't fit in memory."
    },
    {
      "id": "sort-15",
      "type": "multiple_choice",
      "difficulty": "medium",
      "question": "What data structure is used in Heap Sort?",
      "options": ["Linked List", "Queue", "Stack", "Binary Heap"],
      "correctAnswer": 3,
      "explanation": "Heap Sort uses a Binary Heap data structure to efficiently extract maximum/minimum elements."
    },
    {
      "id": "sort-16",
      "type": "true_false",
      "difficulty": "medium",
      "question": "Selection Sort is a stable sorting algorithm.",
      "correctAnswer": false,
      "explanation": "Selection Sort is not stable because it may change the relative order of equal elements during swaps."
    },
    {
      "id": "sort-17",
      "type": "multiple_choice",
      "difficulty": "easy",
      "question": "Which sorting algorithm is known for its adaptability?",
      "options": ["Heap Sort", "Selection Sort", "Insertion Sort", "Quick Sort"],
      "correctAnswer": 2,
      "explanation": "Insertion Sort is adaptive and performs well on partially sorted data."
    },
    {
      "id": "sort-18",
      "type": "multiple_choice",
      "difficulty": "hard",
      "question": "What is the time complexity of building a heap in Heap Sort?",
      "options": ["O(n)", "O(n log n)", "O(n²)", "O(1)"],
      "correctAnswer": 0,
      "explanation": "Building a heap from an unsorted array can be done in O(n) time using the bottom-up approach."
    },
    {
      "id": "sort-19",
      "type": "true_false",
      "difficulty": "easy",
      "question": "Bubble Sort is the most efficient sorting algorithm for large datasets.",
      "correctAnswer": false,
      "explanation": "Bubble Sort is one of the least efficient algorithms for large datasets due to its O(n²) time complexity."
    },
    {
      "id": "sort-20",
      "type": "multiple_choice",
      "difficulty": "medium",
      "question": "Which sorting algorithm uses a pivot element?",
      "options": ["Merge Sort", "Quick Sort", "Heap Sort", "Insertion Sort"],
      "correctAnswer": 1,
      "explanation": "Quick Sort uses a pivot element to partition the array into two sub-arrays."
    },
    {
      "id": "sort-21",
      "type": "multiple_choice",
      "difficulty": "hard",
      "question": "What is the worst-case space complexity of Quick Sort?",
      "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
      "correctAnswer": 2,
      "explanation": "In the worst case (unbalanced partitions), Quick Sort can have O(n) space complexity due to recursion stack depth."
    },
    {
      "id": "sort-22",
      "type": "true_false",
      "difficulty": "medium",
      "question": "Counting Sort is a comparison-based sorting algorithm.",
      "correctAnswer": false,
      "explanation": "Counting Sort is a non-comparison based algorithm that uses the range of input values to sort."
    },
    {
      "id": "sort-23",
      "type": "multiple_choice",
      "difficulty": "medium",
      "question": "Which sorting algorithm is typically the default in programming language libraries?",
      "options": ["Bubble Sort", "Selection Sort", "Quick Sort", "Insertion Sort"],
      "correctAnswer": 2,
      "explanation": "Quick Sort is often the default in many programming language libraries due to its good average-case performance."
    }
  ]
}