{
  "algorithm": {
    "id": "merge_sort",
    "name": "Merge Sort",
    "category": "Sorting Algorithms",
    "description": "An efficient, stable, comparison-based sorting algorithm that uses the divide-and-conquer approach to sort elements by recursively splitting the array into smaller subarrays and then merging them back in sorted order."
  },
  "sections": [
    {
      "id": "analogy",
      "label": "Analogy",
      "content": "Imagine you're organizing a large deck of cards. Instead of trying to sort the entire deck at once, you divide it into two smaller piles. Then you divide each of those piles into even smaller piles, continuing until you have many tiny piles of just one card each (which are already sorted). Now you start merging these tiny piles back together: you take two single-card piles and combine them into a sorted 2-card pile, then combine two 2-card piles into a sorted 4-card pile, and so on. Each time you merge, you carefully compare the top cards from each pile to decide which one should come next, ensuring the merged pile stays sorted."
    },
    {
      "id": "concept",
      "label": "Concept",
      "content": "Merge Sort is a divide-and-conquer algorithm that works by recursively breaking down a list into smaller sublists until each sublist consists of a single element, and then repeatedly merging those sublists to produce new sorted sublists until there is only one sorted list remaining.\n\n**Key Idea:** Divide the problem into smaller subproblems, solve them recursively, and then combine the solutions to solve the original problem. The \"merge\" operation is the heart of this algorithm, efficiently combining two sorted arrays into one sorted array."
    },
    {
      "id": "process",
      "label": "General Step-by-Step Process",
      "content": "```mermaid\nflowchart TD\n    A[Start Merge Sort] --> B{array has more than<br>one element?}\n    B -->|No| C[Return array]\n    B -->|Yes| D[Find middle index: mid]\n    D --> E[Recursively sort left half:<br>left = mergeSortarr, left, mid]\n    D --> F[Recursively sort right half:<br>right = mergeSortarr, mid+1, right]\n    E --> G[Merge sorted halves]\n    F --> G\n    G --> H[Return merged sorted array]\n\n    subgraph Merge Process\n        I[Initialize pointers i=0, j=0, k=0] --> J{i < left.length AND<br>j < right.length?}\n        J -->|Yes| K{left[i] <= right[j]?}\n        K -->|Yes| L[Add left[i] to result<br>Increment i]\n        K -->|No| M[Add right[j] to result<br>Increment j]\n        L --> N[Increment k] --> J\n        M --> N\n        J -->|No| O[Add remaining elements<br>from left or right]\n        O --> P[Return merged array]\n    end\n```\n\n**Process Breakdown:**\n1. **Divide:** Split the array into two halves\n2. **Conquer:** Recursively sort both halves\n3. **Combine:** Merge the two sorted halves into one sorted array\n4. **Base Case:** Arrays of size 0 or 1 are already sorted"
    },
    {
      "id": "example",
      "label": "Example Sorting",
      "content": "**Initial Array:** `[38, 27, 43, 3, 9, 82, 10]`\n\n**Division Phase:**\n```\nLevel 1: [38, 27, 43, 3] | [9, 82, 10]\nLevel 2: [38, 27] | [43, 3] | [9, 82] | [10]\nLevel 3: [38] | [27] | [43] | [3] | [9] | [82] | [10]\n```\n\n**Merging Phase:**\n```\nMerge [38] and [27] → [27, 38]\nMerge [43] and [3] → [3, 43]\nMerge [27, 38] and [3, 43] → [3, 27, 38, 43]\n\nMerge [9] and [82] → [9, 82]\nMerge [10] with [9, 82] → [9, 10, 82]\n\nFinal Merge: [3, 27, 38, 43] and [9, 10, 82] → [3, 9, 10, 27, 38, 43, 82]\n```\n\n**Final Array:** `[3, 9, 10, 27, 38, 43, 82]`"
    },
    {
      "id": "properties",
      "label": "Algorithm Properties",
      "content": "### Time Complexity:\n- **Best Case:** O(n log n)\n- **Worst Case:** O(n log n)\n- **Average Case:** O(n log n)\n\n### Space Complexity:\n- **O(n)** - Requires additional space for temporary arrays during merging\n\n### Stability:\n- **Stable:** Yes - equal elements maintain their relative order\n\n### Recursion:\n- **Recursive Algorithm:** Uses recursion for the divide step\n- **Stack Depth:** O(log n) recursive calls\n\n### When to Use Merge Sort:\n\n**✅ Suitable for:**\n- Large datasets where consistent performance is important\n- Linked lists (efficient for sequential access)\n- External sorting (sorting data that doesn't fit in memory)\n- Situations requiring stable sorting\n- When worst-case performance matters\n\n**❌ Not suitable for:**\n- Memory-constrained environments (due to O(n) space)\n- Very small arrays (insertion sort might be better)\n- Arrays that are already mostly sorted\n\n### Advantages:\n- Guaranteed O(n log n) performance in all cases\n- Stable sorting algorithm\n- Well-suited for parallel processing\n- Excellent for linked lists and external sorting\n- Predictable performance\n\n### Disadvantages:\n- Requires O(n) additional memory space\n- Slower than quick sort for arrays in practice\n- Not an in-place algorithm\n- Recursive implementation may cause stack overflow for very large arrays\n\n### Optimization Tips:\n1. **Use Insertion Sort for small subarrays** (typically when n < 10-15)\n2. **Avoid copying** by alternating the direction of merging\n3. **Parallelize** the sorting of subarrays\n4. **Iterative implementation** to avoid recursion overhead"
    }
  ],
  "code_examples": {
    "python": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result",
    "javascript": "function mergeSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    \n    const mid = Math.floor(arr.length / 2);\n    const left = mergeSort(arr.slice(0, mid));\n    const right = mergeSort(arr.slice(mid));\n    \n    return merge(left, right);\n}\n\nfunction merge(left, right) {\n    const result = [];\n    let i = 0, j = 0;\n    \n    while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            result.push(left[i]);\n            i++;\n        } else {\n            result.push(right[j]);\n            j++;\n        }\n    }\n    \n    return result.concat(left.slice(i)).concat(right.slice(j));\n}",
    "java": "public static void mergeSort(int[] arr) {\n    if (arr.length <= 1) return;\n    \n    int mid = arr.length / 2;\n    int[] left = Arrays.copyOfRange(arr, 0, mid);\n    int[] right = Arrays.copyOfRange(arr, mid, arr.length);\n    \n    mergeSort(left);\n    mergeSort(right);\n    \n    merge(arr, left, right);\n}\n\nprivate static void merge(int[] arr, int[] left, int[] right) {\n    int i = 0, j = 0, k = 0;\n    \n    while (i < left.length && j < right.length) {\n        if (left[i] <= right[j]) {\n            arr[k++] = left[i++];\n        } else {\n            arr[k++] = right[j++];\n        }\n    }\n    \n    while (i < left.length) {\n        arr[k++] = left[i++];\n    }\n    \n    while (j < right.length) {\n        arr[k++] = right[j++];\n    }\n}",
    "cpp": "void merge(int arr[], int left, int mid, int right) {\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    int* L = new int[n1];\n    int* R = new int[n2];\n    \n    for (int i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n    \n    int i = 0, j = 0, k = left;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n    \n    delete[] L;\n    delete[] R;\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left >= right) return;\n    \n    int mid = left + (right - left) / 2;\n    mergeSort(arr, left, mid);\n    mergeSort(arr, mid + 1, right);\n    merge(arr, left, mid, right);\n}",
    "c": "void merge(int arr[], int left, int mid, int right) {\n    int i, j, k;\n    int n1 = mid - left + 1;\n    int n2 = right - mid;\n    \n    int L[n1], R[n2];\n    \n    for (i = 0; i < n1; i++)\n        L[i] = arr[left + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[mid + 1 + j];\n    \n    i = 0;\n    j = 0;\n    k = left;\n    \n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n    \n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n    \n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\nvoid mergeSort(int arr[], int left, int right) {\n    if (left < right) {\n        int mid = left + (right - left) / 2;\n        \n        mergeSort(arr, left, mid);\n        mergeSort(arr, mid + 1, right);\n        \n        merge(arr, left, mid, right);\n    }\n}"
  },
  "metadata": {
    "difficulty": "Intermediate",
    "last_updated": "2024-01-15",
    "tags": ["sorting", "divide-and-conquer", "stable", "recursive", "comparison-based"]
  }
}